//
// This file is automatically generated by Facc
// https://github.com/fawdlstty/Fapp
//



#ifndef __PUBLIC_OPT_AST_HPP__
#define __PUBLIC_OPT_AST_HPP__



#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

#include <fmt/core.h>

#include <Facc/IEnumerator.hpp>
#include <Facc/Parser/IAST.h>
#include <Facc/Parser/AstParser.hpp>



class PublicOptAST: IAST {
public:
	// public_opt ::= ('public' | 'internal' | 'protected' | 'private')?

	std::shared_ptr<AstParser> Parser;

	IEnumerator<int> TryParse (int _pos) override {
		if (!Parser->TryReg ("PublicOptAST", _pos))
			co_return;
		auto _0_enum = _try_parse_0 (_pos);
		while (_0_enum.MoveNext ()) {
			ValidIndex = 0;
			co_yield _0_enum.Current;
		}
		auto _1_enum = _try_parse_1 (_pos);
		while (_1_enum.MoveNext ()) {
			ValidIndex = 1;
			co_yield _1_enum.Current;
		}
		auto _2_enum = _try_parse_2 (_pos);
		while (_2_enum.MoveNext ()) {
			ValidIndex = 2;
			co_yield _2_enum.Current;
		}
		auto _3_enum = _try_parse_3 (_pos);
		while (_3_enum.MoveNext ()) {
			ValidIndex = 3;
			co_yield _3_enum.Current;
		}
		ValidIndex = -1;
		co_yield _pos;
		Parser->UnReg ("PublicOptAST", _pos);
	}

	IEnumerator<int> _try_parse_0 (int _pos);
	IEnumerator<int> _try_parse_1 (int _pos);
	IEnumerator<int> _try_parse_2 (int _pos);
	IEnumerator<int> _try_parse_3 (int _pos);
	bool IsValid () override;
	void PrintTree (int _indent);
	int size ();

	std::string Value_0 = "";
	std::string Value_1 = "";
	std::string Value_2 = "";
	std::string Value_3 = "";
	int ValidIndex = -1;
};



inline bool PublicOptAST::IsValid () {
	return ValidIndex >= 0;
}

inline void PublicOptAST::PrintTree (int _indent) {
	if (ValidIndex == 0) {
		std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0 << ']' << std::endl;
	} else if (ValidIndex == 1) {
		std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_1 << ']' << std::endl;
	} else if (ValidIndex == 2) {
		std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_2 << ']' << std::endl;
	} else if (ValidIndex == 3) {
		std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_3 << ']' << std::endl;
	}
}

inline int PublicOptAST::size () {
	int _len = 0;
	_len += Value_0.size ();
	_len += Value_1.size ();
	_len += Value_2.size ();
	_len += Value_3.size ();
	return _len;
}
inline IEnumerator<int> PublicOptAST::_try_parse_0 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "public")) {
		Value_0 = "public";
		co_yield _pos + Value_0.size ();
		Value_0 = "";
	}
}

inline IEnumerator<int> PublicOptAST::_try_parse_1 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "internal")) {
		Value_1 = "internal";
		co_yield _pos + Value_1.size ();
		Value_1 = "";
	}
}

inline IEnumerator<int> PublicOptAST::_try_parse_2 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "protected")) {
		Value_2 = "protected";
		co_yield _pos + Value_2.size ();
		Value_2 = "";
	}
}

inline IEnumerator<int> PublicOptAST::_try_parse_3 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "private")) {
		Value_3 = "private";
		co_yield _pos + Value_3.size ();
		Value_3 = "";
	}
}



#endif // __PUBLIC_OPT_AST_HPP__
