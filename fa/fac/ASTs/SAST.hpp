//
// This file is automatically generated by Facc
// https://github.com/fawdlstty/Fapp
//



#ifndef __S_AST_HPP__
#define __S_AST_HPP__



#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

#include <fmt/core.h>

#include <Facc/IEnumerator.hpp>
#include <Facc/Parser/IAST.h>
#include <Facc/Parser/AstParser.hpp>



class SAST_0_1: IAST {
public:
	// [part of] s ::= '\x30\x30' ^'\n' '\n'

	std::shared_ptr<AstParser> Parser;

	IEnumerator<int> TryParse (int _pos) override {
		if (!Parser->TryReg ("SAST_0_1", _pos))
			co_return;
		auto _0_1_0_enum = _try_parse_0_1_0 (_pos);
		while (_0_1_0_enum.MoveNext ()) {
			auto _0_1_1_enum = _try_parse_0_1_1 (_0_1_0_enum.Current);
			while (_0_1_1_enum.MoveNext ()) {
				auto _0_1_2_enum = _try_parse_0_1_2 (_0_1_1_enum.Current);
				while (_0_1_2_enum.MoveNext ()) {
					co_yield _0_1_2_enum.Current;
				}
			}
		}
		Parser->UnReg ("SAST_0_1", _pos);
	}

	IEnumerator<int> _try_parse_0_1_0 (int _pos);
	IEnumerator<int> _try_parse_0_1_1 (int _pos);
	IEnumerator<int> _try_parse_0_1_2 (int _pos);
	bool IsValid () override;
	void PrintTree (int _indent);
	int size ();

	std::string Value_0_1_0 = "";
	std::string Value_0_1_1 = "";
	std::string Value_0_1_2 = "";
};



class SAST_0_2: IAST {
public:
	// [part of] s ::= '\x30*' ^'*\x30' '*\x30'

	std::shared_ptr<AstParser> Parser;

	IEnumerator<int> TryParse (int _pos) override {
		if (!Parser->TryReg ("SAST_0_2", _pos))
			co_return;
		auto _0_2_0_enum = _try_parse_0_2_0 (_pos);
		while (_0_2_0_enum.MoveNext ()) {
			auto _0_2_1_enum = _try_parse_0_2_1 (_0_2_0_enum.Current);
			while (_0_2_1_enum.MoveNext ()) {
				auto _0_2_2_enum = _try_parse_0_2_2 (_0_2_1_enum.Current);
				while (_0_2_2_enum.MoveNext ()) {
					co_yield _0_2_2_enum.Current;
				}
			}
		}
		Parser->UnReg ("SAST_0_2", _pos);
	}

	IEnumerator<int> _try_parse_0_2_0 (int _pos);
	IEnumerator<int> _try_parse_0_2_1 (int _pos);
	IEnumerator<int> _try_parse_0_2_2 (int _pos);
	bool IsValid () override;
	void PrintTree (int _indent);
	int size ();

	std::string Value_0_2_0 = "";
	std::string Value_0_2_1 = "";
	std::string Value_0_2_2 = "";
};



class SAST_0: IAST {
public:
	// s ::= ([ \t\r\n] | ('\x30\x30' ^'\n' '\n') | ('\x30*' ^'*\x30' '*\x30'))*

	std::shared_ptr<AstParser> Parser;

	IEnumerator<int> TryParse (int _pos) override {
		if (!Parser->TryReg ("SAST_0", _pos))
			co_return;
		auto _0_0_enum = _try_parse_0_0 (_pos);
		while (_0_0_enum.MoveNext ()) {
			ValidIndex_0 = 0;
			co_yield _0_0_enum.Current;
		}
		auto _0_1_enum = _try_parse_0_1 (_pos);
		while (_0_1_enum.MoveNext ()) {
			ValidIndex_0 = 1;
			co_yield _0_1_enum.Current;
		}
		auto _0_2_enum = _try_parse_0_2 (_pos);
		while (_0_2_enum.MoveNext ()) {
			ValidIndex_0 = 2;
			co_yield _0_2_enum.Current;
		}
		ValidIndex_0 = -1;
		co_yield _pos;
		Parser->UnReg ("SAST_0", _pos);
	}

	IEnumerator<int> _try_parse_0_0 (int _pos);
	IEnumerator<int> _try_parse_0_1 (int _pos);
	IEnumerator<int> _try_parse_0_2 (int _pos);
	bool IsValid () override;
	void PrintTree (int _indent);
	int size ();

	std::string Value_0_0 = "";
	std::shared_ptr<SAST_0_1> Value_0_1;
	std::shared_ptr<SAST_0_2> Value_0_2;
	int ValidIndex_0 = -1;
};



class SAST: IAST {
public:
	// [wrap of] s ::= ([ \t\r\n] | ('\x30\x30' ^'\n' '\n') | ('\x30*' ^'*\x30' '*\x30'))*

	std::shared_ptr<AstParser> Parser;

	IEnumerator<int> TryParse (int _pos) override {
		if (!Parser->TryReg ("SAST", _pos))
			co_return;
		auto _0_enum = _try_parse_0 (_pos);
		while (_0_enum.MoveNext ()) {
			co_yield _0_enum.Current;
		}
		Parser->UnReg ("SAST", _pos);
	}

	IEnumerator<int> _try_parse_0 (int _pos);
	bool IsValid () override;
	void PrintTree (int _indent);
	int size ();

	std::vector<std::shared_ptr<SAST_0>> Value_0;
};



inline bool SAST_0_1::IsValid () {
	return (Value_0_1_0.size () > 0 && Value_0_1_1.size () > 0 && Value_0_1_2.size () > 0);
}

inline void SAST_0_1::PrintTree (int _indent) {
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_1_0 << ']' << std::endl;
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_1_1 << ']' << std::endl;
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_1_2 << ']' << std::endl;
}

inline int SAST_0_1::size () {
	int _len = 0;
	_len += Value_0_1_0.size ();
	_len += Value_0_1_1.size ();
	_len += Value_0_1_2.size ();
	return _len;
}
inline IEnumerator<int> SAST_0_1::_try_parse_0_1_0 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "\x30\x30")) {
		Value_0_1_0 = "\x30\x30";
		co_yield _pos + Value_0_1_0.size ();
		Value_0_1_0 = "";
	}
}

inline IEnumerator<int> SAST_0_1::_try_parse_0_1_1 (int _pos) {
	Parser->SetErrorPos (_pos);
	int _len = Parser->MatchReverseString (_pos, "\n");
	Value_0_1_1 = Parser->GetPartCode (_pos, _len);
	co_yield _pos + Value_0_1_1.size ();
	Value_0_1_1 = "";
}

inline IEnumerator<int> SAST_0_1::_try_parse_0_1_2 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "\n")) {
		Value_0_1_2 = "\n";
		co_yield _pos + Value_0_1_2.size ();
		Value_0_1_2 = "";
	}
}

inline bool SAST_0_2::IsValid () {
	return (Value_0_2_0.size () > 0 && Value_0_2_1.size () > 0 && Value_0_2_2.size () > 0);
}

inline void SAST_0_2::PrintTree (int _indent) {
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_2_0 << ']' << std::endl;
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_2_1 << ']' << std::endl;
	std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_2_2 << ']' << std::endl;
}

inline int SAST_0_2::size () {
	int _len = 0;
	_len += Value_0_2_0.size ();
	_len += Value_0_2_1.size ();
	_len += Value_0_2_2.size ();
	return _len;
}
inline IEnumerator<int> SAST_0_2::_try_parse_0_2_0 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "\x30*")) {
		Value_0_2_0 = "\x30*";
		co_yield _pos + Value_0_2_0.size ();
		Value_0_2_0 = "";
	}
}

inline IEnumerator<int> SAST_0_2::_try_parse_0_2_1 (int _pos) {
	Parser->SetErrorPos (_pos);
	int _len = Parser->MatchReverseString (_pos, "*\x30");
	Value_0_2_1 = Parser->GetPartCode (_pos, _len);
	co_yield _pos + Value_0_2_1.size ();
	Value_0_2_1 = "";
}

inline IEnumerator<int> SAST_0_2::_try_parse_0_2_2 (int _pos) {
	Parser->SetErrorPos (_pos);
	if (Parser->TryMatchString (_pos, "*\x30")) {
		Value_0_2_2 = "*\x30";
		co_yield _pos + Value_0_2_2.size ();
		Value_0_2_2 = "";
	}
}

inline bool SAST_0::IsValid () {
	return ValidIndex_0 >= 0;
}

inline void SAST_0::PrintTree (int _indent) {
	if (ValidIndex_0 == 0) {
		std::cout << std::string ((_indent + 1) * 4, ' ') << '[' << Value_0_0 << ']' << std::endl;
	} else if (ValidIndex_0 == 1) {
		Value_0_1->PrintTree (_indent + 1);
	} else if (ValidIndex_0 == 2) {
		Value_0_2->PrintTree (_indent + 1);
	}
}

inline int SAST_0::size () {
	int _len = 0;
	_len += Value_0_0.size ();
	_len += Value_0_1->size ();
	_len += Value_0_2->size ();
	return _len;
}
inline IEnumerator<int> SAST_0::_try_parse_0_0 (int _pos) {
	Parser->SetErrorPos (_pos);
	Value_0_0 = "";
	std::optional<char> _ch;
	auto _check_0_0 = [] (char _c) { return _c == ' ' || _c == '\t' || _c == '\r' || _c == '\n'; };
	if ((_ch = Parser->TryGetChar (_pos, _check_0_0)).has_value ()) {
		Value_0_0 += _ch.value ();
		co_yield _pos + 1;
		Value_0_0 = "";
	}
}

inline IEnumerator<int> SAST_0::_try_parse_0_1 (int _pos) {
	Parser->SetErrorPos (_pos);
	auto _o = std::make_shared<SAST_0_1> ();
	_o->Parser = Parser;
	auto _enum = _o->TryParse (_pos);
	while (_enum.MoveNext ()) {
		Value_0_1 = _o;
		co_yield _enum.Current;
		Value_0_1 = nullptr;
	}
}
inline IEnumerator<int> SAST_0::_try_parse_0_2 (int _pos) {
	Parser->SetErrorPos (_pos);
	auto _o = std::make_shared<SAST_0_2> ();
	_o->Parser = Parser;
	auto _enum = _o->TryParse (_pos);
	while (_enum.MoveNext ()) {
		Value_0_2 = _o;
		co_yield _enum.Current;
		Value_0_2 = nullptr;
	}
}

inline bool SAST::IsValid () {
	return Value_0.size () > 0;
}

inline void SAST::PrintTree (int _indent) {
	for (size_t i = 0; i < Value_0.size (); ++i)
		Value_0 [i]->PrintTree (_indent + 1);
}

inline int SAST::size () {
	int _len = 0;
	for (size_t i = 0; i < Value_0.size (); ++i)
		_len += Value_0 [i]->size ();
	return _len;
}
inline IEnumerator<int> SAST::_try_parse_0 (int _pos) {
	Parser->SetErrorPos (_pos);
	auto _o = std::make_shared<SAST_0> ();
	_o->Parser = Parser;
	auto _enum = _o->TryParse (_pos);
	while (_enum.MoveNext ()) {
		int _list_pos = Value_0.size ();
		Value_0.push_back (_o);
		co_yield _enum.Current;
		auto _enum1 = _try_parse_0 (_enum.Current);
		while (_enum1.MoveNext ())
			co_yield _enum1.Current;
		Value_0.erase (Value_0.begin () + _list_pos);
	}
	co_yield _pos;
}



#endif // __S_AST_HPP__
